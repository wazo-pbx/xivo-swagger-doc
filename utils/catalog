#!/usr/bin/env python
import abc
import click
import collections
import fnmatch
import json
import os
import requests
import shutil
import uuid
import yaml

ROOT_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..'))
DEFAULT_REPOS = os.path.join(ROOT_DIR, 'contribs', 'repos')
API_GITHUB_URL = "https://api.github.com/repos/xivo-pbx/{}/contents/{}"

GITHUB_URL = "https://raw.githubusercontent.com/xivo-pbx/{repo}/{branch}/{folder}/{filename}"


class SpecScanner(object):

    def __init__(self, root):
        self.root = root

    def scan(self):
        for path, dirs, files in os.walk(self.root, followlinks=True):
            files = fnmatch.filter(files, '*.json') + fnmatch.filter(files, '*.yml')
            for filepath, spec, file_extension in self.filter_specs(path, files):
                yield filepath, spec, file_extension

    def filter_specs(self, path, files):
        for filename in files:
            file_extension = 'yml'
            if filename.endswith('json'):
                file_extension = 'json'

            filepath = os.path.join(path, filename)
            spec = self.load_spec(filepath, file_extension)
            if spec and self.is_swagger_spec(spec):
                yield filepath, spec, file_extension

    def load_spec(self, filepath, file_extension):
        with open(filepath) as f:
            try:
                if file_extension == 'json':
                    return json.loads(f.read())
                return yaml.load(f.read())
            except ValueError:
                return None

    def is_swagger_spec(self, spec):
        if 'swagger' not in spec:
            return False
        return str(spec['swagger']) >= "2"


class CatalogBuilder(object):

    __metaclass__ = abc.ABCMeta

    index_filename = "index.json"

    def __init__(self, destination):
        self.destination = destination

    @abc.abstractmethod
    def build(self, scanner):
        pass

    def write_index(self, items):
        items = self.sort_items(items)
        catalog = {'apis': items}
        index_path = os.path.join(self.destination, self.index_filename)
        data = json.dumps(catalog, indent=4, separators=(',', ': '))
        with open(index_path, 'w') as f:
            f.write(data)

    def sort_items(self, items):
        return sorted(items, key=lambda i: i['title'].lower())


class StaticBuilder(CatalogBuilder):

    def __init__(self, destination, prefix="/doc/catalog"):
        super(StaticBuilder, self).__init__(destination)
        self.prefix = prefix

    def build(self, scanner):
        items = []
        for filepath, spec, file_extension in scanner.scan():
            items.append(self.build_item(spec, file_extension))
            self.copy_spec(spec, filepath, file_extension)

        self.write_index(items)

    def build_item(self, spec, file_extension):
        url = "{}/{}.{}".format(self.prefix, spec['x-xivo-name'], file_extension)
        return {'title': spec['info']['title'],
                'url': url}

    def copy_spec(self, spec, filepath, file_extension):
        filename = "{}.{}".format(spec['x-xivo-name'], file_extension)
        destination = os.path.join(self.destination, filename)
        shutil.copy(filepath, destination)


@click.command()
@click.argument('specs', type=click.Path(exists=True, file_okay=False))
@click.option('--destination', default='catalog', type=click.Path(file_okay=False))
@click.option('--prefix', default="/catalog")
def build_static(specs, destination, prefix):
    if not os.path.exists(destination):
        os.makedirs(destination)
    scanner = SpecScanner(specs)
    builder = StaticBuilder(destination, prefix=prefix)
    builder.build(scanner)


@click.command()
@click.option('--repos', type=click.Path(exists=True), default=DEFAULT_REPOS)
@click.option('--branch', default='master')
@click.option('--destination', default='catalog', type=click.Path())
def download(repos, branch, destination):
    if not os.path.exists(destination):
        os.makedirs(destination)

    with open(repos) as f:
        configs = yaml.load(f)

    for repo, config in configs.iteritems():
        download_spec(repo, config, branch, destination)


def download_spec(repo, config, branch, destination):
    file_extension = 'yml'
    if config['file'].endswith('json'):
        file_extension = 'json'

    filepath = os.path.join(destination, str(uuid.uuid4()) + '.' + file_extension)

    if config['many']:
        spec = download_github_files(repo, config, branch, file_extension)
    else:
        url = GITHUB_URL.format(repo=repo,
                                branch=branch,
                                folder=config['folder'],
                                filename=config['file'])
        spec = download_github_file(url, file_extension)

    if spec.get('info'):
        with open(filepath, 'wb') as f:
            if file_extension == 'json':
                f.write(json.dumps(spec))
            else:
                f.write(yaml.dump(spec))
    else:
        raise Exception("could not download spec for {}".format(repo))


def download_github_files(repo, config, branch, file_extension):
    url = API_GITHUB_URL.format(repo, config['folder'])
    response = requests.get(url, params={'ref': branch})
    if response.status_code != 200:
        raise Exception("could not download {}".format(url))

    api_spec = {}
    for folder in json.loads(response.text):
        if folder.get('type') != 'dir':
            continue
        url = GITHUB_URL.format(repo=repo,
                                branch=branch,
                                folder='{}/{}'.format(config['folder'], folder['name']),
                                filename=config['file'])
        single_spec = download_github_file(url, file_extension)
        api_spec = update(api_spec, single_spec)
    return api_spec


def download_github_file(url, file_extension):
    response = requests.get(url)
    if response.status_code == 200:
        if file_extension == 'json':
            return json.loads(response.text)
        return yaml.load(response.text)
    else:
        return {}


def update(a, b):
    for key, value in b.iteritems():
        if isinstance(value, collections.Mapping):
            result = update(a.get(key, {}), value)
            a[key] = result
        else:
            a[key] = b[key]
    return a


if __name__ == "__main__":
    group = click.Group()
    group.add_command(build_static)
    group.add_command(download)
    group()
